<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Sto. Niño High School — Web Map Navigator</title>

    <!-- Bootstrap -->
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <!-- Leaflet -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />

    <style>
      body {
        font-family: Inter, system-ui, Segoe UI, Roboto, Helvetica, Arial,
          sans-serif;
        background: #f7f9fc;
      }
      .container {
        max-width: 1200px;
      }
      #map {
        height: 640px;
        border-radius: 12px;
        box-shadow: 0 6px 20px rgba(16, 24, 40, 0.06);
      }
      .controls-row {
        margin-bottom: 12px;
      }
      /* arrow marker style (div icon) */
      .arrow-icon {
        width: 36px;
        height: 36px;
        border-radius: 6px;
        background: #ff8a00;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: 700;
      }
      .legend-badge {
        display: inline-block;
        padding: 6px 8px;
        border-radius: 6px;
        margin-right: 6px;
      }
    </style>
  </head>
  <body>
    <div class="container py-4">
      <h2 class="text-center mb-3 text-primary">
        Sto. Niño High School — Web Map Navigator
      </h2>

      <div class="row controls-row g-2 align-items-center">
        <div class="col-md-5">
          <select id="destination" class="form-select">
            <option selected disabled>Choose destination...</option>
          </select>
        </div>
        <div class="col-md-7 text-end">
          <button id="startBtn" class="btn btn-primary">
            Start Navigation
          </button>
          <button id="resetBtn" class="btn btn-outline-secondary">Reset</button>
        </div>
      </div>

      <div id="map"></div>

      <div class="mt-3 text-muted small">
        Routes are color-coded. This map uses your satellite image as a
        georeferenced overlay and places markers using the provided bounding
        box.
      </div>
    </div>

    <!-- Libraries -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
      // --- Provided bounding box coordinates (approx corners) ---
      const bboxCoords = [
        [14.986295929130735, 120.89085011453284],
        [14.986466933800223, 120.89190288157644],
        [14.985637818976567, 120.89097483725264],
        [14.985781618808993, 120.89207856626777],
      ];

      // Compute bounding LatLngBounds (min/max) to feed to imageOverlay
      const lats = bboxCoords.map((c) => c[0]);
      const lngs = bboxCoords.map((c) => c[1]);
      const south = Math.min(...lats);
      const north = Math.max(...lats);
      const west = Math.min(...lngs);
      const east = Math.max(...lngs);
      const imageBounds = [
        [south, west],
        [north, east],
      ]; // SW, NE

      // init map
      const map = L.map("map", {
        center: [(south + north) / 2, (west + east) / 2],
        zoom: 19,
        zoomControl: true,
      });

      // Add a light basemap (optional) under the image overlay for reference
      L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        attribution: "",
      }).addTo(map);

      // Add the satellite image as a georeferenced overlay (external image file)
      // Make sure you place the exact satellite PNG at images/sto-nino-map.png
      const imgUrl = "sto-nino-map.png";
      const overlay = L.imageOverlay(imgUrl, imageBounds, { opacity: 1 }).addTo(
        map
      );

      // Fit map to bounds of the overlay nicely
      map.fitBounds(imageBounds);

      // --- Key POIs (approx positions inside the bounding box) ---
      // We will estimate positions by interpolating inside the bounding box.
      function interp(lat1, lng1, lat2, lng2, t) {
        return [lat1 + (lat2 - lat1) * t, lng1 + (lng2 - lng1) * t];
      }

      // Convert percentage offsets (0..1) inside the bbox to LatLng
      function pctToLatLng(px, py) {
        const lat = north + (south - north) * py; // py=0 => north
        const lng = west + (east - west) * px; // px=0 => west
        return [lat, lng];
      }

      // Main gate coordinate provided earlier
      const mainGate = [14.985727, 120.89191];

      // Define POIs with approximate positions (px,py inside bounding box 0..1)
      const POIs = {
        gate: { name: "Main Gate", latlng: mainGate, color: "#0d6efd" },
        admin: {
          name: "Admin Office",
          latlng: pctToLatLng(0.75, 0.55),
          color: "#0d6efd",
        },
        canteen: {
          name: "Canteen",
          latlng: pctToLatLng(0.45, 0.7),
          color: "#ffc107",
        },
        // grade rooms (a few sample rooms each grade)
        "7A": {
          name: "Grade 7A",
          latlng: pctToLatLng(0.5, 0.33),
          color: "#0dcaf0",
        },
        "7B": {
          name: "Grade 7B",
          latlng: pctToLatLng(0.57, 0.33),
          color: "#0dcaf0",
        },
        "8A": {
          name: "Grade 8A",
          latlng: pctToLatLng(0.5, 0.45),
          color: "#198754",
        },
        "9A": {
          name: "Grade 9A",
          latlng: pctToLatLng(0.6, 0.45),
          color: "#6f42c1",
        },
        "10A": {
          name: "Grade 10A",
          latlng: pctToLatLng(0.7, 0.45),
          color: "#0dcaf0",
        },
      };

      // Add markers and populate dropdown
      const destSelect = document.getElementById("destination");
      const markers = {};
      Object.keys(POIs).forEach((key) => {
        const p = POIs[key];
        // If POI latlng already given as lat/lng use it, otherwise it's [lat,lng]
        const marker = L.marker(p.latlng, {
          title: p.name,
          riseOnHover: true,
        })
          .addTo(map)
          .bindPopup(`<strong>${p.name}</strong>`);
        markers[key] = marker;

        if (key !== "gate") {
          const opt = document.createElement("option");
          opt.value = key;
          opt.textContent = p.name;
          destSelect.appendChild(opt);
        }
      });

      // Helper: build a gentle curved route (array of LatLngs) between two LatLng points
      function buildGentleCurve(startLatLng, endLatLng, segments = 80) {
        const [sLat, sLng] = startLatLng;
        const [eLat, eLng] = endLatLng;
        // control point offset to create a gentle curve (perpendicular offset)
        const midLat = (sLat + eLat) / 2;
        const midLng = (sLng + eLng) / 2;
        // perpendicular small offset based on distance
        const offsetFactor = 0.0012; // tune for curvature
        const dx = eLng - sLng;
        const dy = eLat - sLat;
        // perpendicular (normalized)
        const px = -dy;
        const py = dx;
        // normalize
        const len = Math.sqrt(px * px + py * py) || 1;
        const nx = px / len;
        const ny = py / len;
        const cx = midLat + ny * offsetFactor;
        const cy = midLng + nx * offsetFactor;
        // quadratic Bezier sampling
        const pts = [];
        for (let t = 0; t <= 1; t += 1 / segments) {
          const lat =
            (1 - t) * (1 - t) * sLat + 2 * (1 - t) * t * cx + t * t * eLat;
          const lng =
            (1 - t) * (1 - t) * sLng + 2 * (1 - t) * t * cy + t * t * eLng;
          pts.push([lat, lng]);
        }
        return pts;
      }

      // Draw colored route and return polyline
      function drawRoute(toKey) {
        const start = POIs["gate"].latlng;
        const end = POIs[toKey].latlng;
        const pts = buildGentleCurve(start, end, 120);
        const color = POIs[toKey].color || "#ff8a00";
        const poly = L.polyline(pts, {
          color: color,
          weight: 6,
          opacity: 0.95,
        }).addTo(map);
        return { poly, pts };
      }

      // animated arrow: create a divicon marker that we can move & rotate
      const ArrowIcon = L.DivIcon.extend({
        options: { className: "", html: '<div class="arrow-icon">➤</div>' },
      });

      let arrowMarker = null;
      let currentAnimation = null;

      function animateAlong(points, duration = 2200) {
        if (arrowMarker) map.removeLayer(arrowMarker);
        const icon = new ArrowIcon();
        arrowMarker = L.marker(points[0], {
          icon: icon,
          interactive: false,
        }).addTo(map);

        const total = points.length;
        const startTime = performance.now();

        function step(now) {
          const t = Math.min((now - startTime) / duration, 1);
          const idxF = t * (total - 1);
          const idx = Math.floor(idxF);
          const frac = idxF - idx;
          const a = points[idx];
          const b = points[Math.min(idx + 1, total - 1)];
          const lat = a[0] + (b[0] - a[0]) * frac;
          const lng = a[1] + (b[1] - a[1]) * frac;
          arrowMarker.setLatLng([lat, lng]);
          // compute rotation angle
          const angle = (Math.atan2(b[0] - a[0], b[1] - a[1]) * 180) / Math.PI; // note lat,lng swapped for screen angle
          const el = arrowMarker.getElement();
          if (el) el.style.transform = `rotate(${angle}deg)`;

          if (t < 1) currentAnimation = requestAnimationFrame(step);
        }
        currentAnimation = requestAnimationFrame(step);
      }

      // Start navigation flow
      const startBtn = document.getElementById("startBtn");
      const resetBtn = document.getElementById("resetBtn");

      let activeRoute = null;

      startBtn.addEventListener("click", () => {
        const dest = destSelect.value;
        if (!dest) return alert("Please select a destination");
        if (activeRoute) {
          // remove previous
          map.removeLayer(activeRoute.poly);
          if (arrowMarker) map.removeLayer(arrowMarker);
          if (currentAnimation) cancelAnimationFrame(currentAnimation);
        }
        const route = drawRoute(dest);
        activeRoute = route;
        // animate arrow along the route points
        animateAlong(route.pts, 2200);
        // fit map to show whole route comfortably
        map.fitBounds(L.latLngBounds(route.pts).pad(0.25));
      });

      resetBtn.addEventListener("click", () => {
        if (activeRoute) {
          map.removeLayer(activeRoute.poly);
          activeRoute = null;
        }
        if (arrowMarker) {
          map.removeLayer(arrowMarker);
          arrowMarker = null;
        }
        if (currentAnimation) cancelAnimationFrame(currentAnimation);
        map.fitBounds(imageBounds);
        destSelect.selectedIndex = 0;
      });

      // click POI markers to select destination
      Object.keys(POIs).forEach((k) => {
        if (k === "gate") return;
        markers[k].on("click", () => {
          destSelect.value = k;
        });
      });

      // helpful: show the bounding box corners in console for debugging
      console.log("Image bounds (SW,NE):", imageBounds);
    </script>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  </body>
</html>
